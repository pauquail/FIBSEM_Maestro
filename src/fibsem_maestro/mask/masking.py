import numpy as np
from matplotlib import pyplot as plt, patches
from skimage.measure import regionprops
import logging

from fibsem_maestro.mask.mask_utils import TfModel, ImageSizeConvertor
from fibsem_maestro.tools.image_tools import crop_image, find_blobs, filter_blobs_min_area, largest_rectangles_in_blobs


class MaskingModel(TfModel):
    def __init__(self, settings):
        super().__init__(settings['model_path'],
                         iterative_training=settings['iterative_training'],
                         patch_size=settings['patch_size'],
                         downsampling_factor=settings['downsampling_factor'],
                         fill_holes=settings['fill_holes']
                         )
        # settings
        self.name = settings['name']
        self.update_mask = settings['update_mask']
        self.mask_image_li = settings['mask_image_li']
        self.min_fraction = settings['min_fraction']
        self.threshold = settings['threshold']
        self.min_area = settings['min_area']

        # default values
        self._image = None  # input image
        self._mask = None  # mask generated by model
        self._labeled_mask = None  # labeled mask
        self._criterion_rectangles = None  # biggest possible rect in each blob in mask
        self._criterion_images = None  # cropped input image base of rects

    def _process_mask(self, processed_image):
        self._labeled_mask = find_blobs(self._mask)
        self._labeled_mask = filter_blobs_min_area(self._labeled_mask, self.min_area)
        self._criterion_rectangles = largest_rectangles_in_blobs(self._labeled_mask)
        # crop images from criterion rectangles
        self._criterion_images = []
        for r in self._criterion_rectangles:
            self._criterion_images.append(crop_image(processed_image, r))

    def mask_image(self, line_number=None, processed_image=None):
        """

        :param line_number: The line number of the image to be masked. If None, all images will be masked.
        :param processed_image: If set, the final cropping will be from this image (otherwise it will be from the
        input image).
        :return: A list of cropped input image masked on mask.

        This method masks image (rectangles) based on a predicted mask. If a line number is provided,
        only the image at that line number will be masked. Otherwise, while image will be masked.

        """
        self._mask = self.predict(self._image)

        if line_number is not None:
            mask_image = self._mask[line_number]
        else:
            mask_image = self._mask
        # check the min_fraction
        if np.sum(mask_image) / len(mask_image) < self.min_fraction:
            logging.warning('Focus criterion: Not enough masked pixels')
            return None
        else:
            if processed_image is None:
                self._process_mask(self._image)  # crop from input image
            else:
                # convert to the same size as input image
                processed_image = ImageSizeConvertor(processed_image, self._image)()
                self._process_mask(processed_image)  # crop from argument image
            return self._criterion_images

    def update_img(self, beam, image_for_mask=None):
        """ Based on update_mask setting, it grabs new image, or it takes last image passes as argument."""
        if self.update_mask:
            self._grab_img(beam)
            logging.debug('Image for the new mask grabbed')
        else:
            if image_for_mask is None:
                logging.warning("Image for masking is not available! Grabbing new image")
                self._grab_img(beam)
            else:
                self._set_img(image_for_mask)
                logging.debug('Image for the new mask updated')

    def _set_img(self, img):
        """ Update input image """
        self._image = np.array(img)

    def _grab_img(self, beam):
        """ Grab new input image"""
        beam.line_integration = self.mask_image_li
        img = beam.grab_frame()
        self._set_img(img)

    def save_log_files(self, filename_prefix):
        """ Save images log images: mask, original image with rectangles"""
        def plot_image_rectangles():
            # Create figure and axes
            fig, ax = plt.subplots(1)

            # Display the image
            ax.imshow(self._image)

            # Create a Rectangle patch for each rectangle and add it to the plot
            for rectangle in self._criterion_rectangles:
                y1, x1, y2, x2 = rectangle
                rect = patches.Rectangle((x1, y1), x2 - x1, y2 - y1, linewidth=1, edgecolor='r', facecolor='none')
                ax.add_patch(rect)
            fig.tight_layout()
            return fig

        def plot_mask():
            # Create figure and axes
            fig, ax = plt.subplots(1)
            # Display the image
            ax.imshow(self._mask)
            fig.tight_layout()
            return fig

        # Mask image
        mask_filename = filename_prefix + '_mask.png'
        fig = plot_mask()
        fig.savefig(mask_filename)
        plt.close(fig)
        # Image with rectangles for criterion calculation
        mask_filename = filename_prefix + '_rectangles_mask.png'
        fig = plot_image_rectangles()
        fig.savefig(mask_filename)
        plt.close(fig)

    @property
    def image_pixel_size(self):  # used for drift correction
        pixel_size = self._image.metadata.binary_result.pixel_size.x
        return pixel_size
