# Global acquisition setting
acquisition:
  library: 'autoscript'  # Microscope control library. Possible values: 'AS'
  wd_correction: 7.88010753607e-9   # For imaging angle 38deg: slice_distance * cos(38). For imaging angle 90: slice_distance
  y_correction:  6.15661475326e-9 # For imaging angle 38deg: slice_distance * sin(38). For imaging angle 90: 0
  additive_beam_shift: [0, 0] # Additive beam shift applied in every cycle
  settings_file: 'microscope_settings.yaml' # Actual microscope setting
  variables_to_save: ['position','electron_beam.working_distance','electron_beam.stigmator','electron_beam.lens_alignment',
                      'electron_beam.beam_shift','electron_beam.detector_contrast','electron_beam.detector_brightness',
                      'electron_beam.dwell_time']
  log: True
  log_level: 10 # 10 - debug, 20 - info, 30 - warning, 40 - error, 50 - critical

# Directories
dirs:
  output_images: 'images'
  log: 'logs'
  template_matching: 'templates'

microscope:
  ip_address: 'localhost'  # ASV server address
  stage_tolerance: 1e-7  # Maximal stage error that is considered as ok
  stage_trials: 3  # Number of trials to reach the goal position before raise error
  beam_shift_tolerance: 50.0e-9 # Maximal beam shift error that is considered as ok
  beam_shift_to_stage_move: [-1, -1] # Axis transformation between beam shift and stage
  image_name: 'image_acquisition'
  criterion_name: 'image_acquisition'

image:
  - name: 'image_acquisition'
    pixel_size: 30.0e-9
    field_of_view: [30.0e-6, 30.0e-6]
    images_line_integration: [1] # li of images acquisition. it is array for multiple acquisition
    bit_depth: 16
  - name: 'autofunction'
    pixel_size: 10.0e-9
    field_of_view: [10.0e-6, 10.0e-6]
    images_line_integration: 64
    bit_depth: 8

criterion_calculation:
  - name: 'image_acquisition'
    border: 0.1 # part of image that does not go to calculation
    tile_size: 10.0e-6 # calculation tile size
    final_resolution: 'min' # how to calculate final resolution from tiles resolution (numpy methods supported)
    final_regions_resolution: 'min' # how to calculate final resolution from different masked regions (numpy methods supported)
    criterion: 'frc_criterion'  # criterion. Values: 'bandpass_criterion', 'bandpass_var_criterion', 'fft_criterion', 'frc_criterion'
    detail: [10.0e-9, 100.0e-9]
    mask_name: 'none'
  - name: 'autofunction'
    border: 0 # part of image that does not go to calculation
    tile_size: 0 # calculation tile size
    final_resolution: 'min' # how to calculate final resolution from tiles resolution (numpy methods supported)
    final_regions_resolution: 'min' # how to calculate final resolution from different masked regions (numpy methods supported)
    criterion: 'bandpass_criterion'  # criterion. Values: 'bandpass_criterion', 'bandpass_var_criterion', 'fft_criterion', 'frc_criterion'
    detail: [ 10.0e-9, 100.0e-9 ]
    mask_name: 'none'

autofunction:
  max_attempts: 8

  af_values:
    - name: 'working_distance - line'
      variable: 'working_distance'
      autofunction: 'AutoFunction'  # type of autofunction. Values: 'none', 'AutoFunction', 'LineAutoFunction'
      sweeping_strategy: 'BasicSweeping' # values: 'BasicSweeping', 'SpiralSweeping'
      sweeping_range: [-10.0e-3, 10.0e-3] # The range of the sweeping variable.
      sweeping_max_limits: [-1, 1] # Limits of sweeping_var
      sweeping_steps: 10 # sweeping steps (in spiral, it is number of steps per cycle)
      sweeping_total_cycles: 1 # sweeping cycles
      execute: 1 # execute condition - if int = number of slices, if float = image resolution
      step_mode: False # Determines whether to perform step mode (it acquires only one image step by step)
      image_name: 'autofunction'
      criterion_name: 'autofunction'
      mask_name: 'none'
      delta_x: 0

mask:
  - name: 'mask'
    update_mask: True # grab image before in order to calculate mask. If False, last image is selected
    mask_image_li: 32 # line integration for mask acquisition
    min_fraction: 0.1 # minimal fraction of mask to proceed to calculation
    downsampling_factor: 4
    model_path: '/home/pavelkrep/data/deepmib_test/seg_exported'
    patch_size: [128, 128]
    threshold: 0.5
    min_area: 100 # use None for disable
    fill_holes: True
    iterative_training: False

email:
  sender: 'pavel.emcf@gmail.com'
  receiver: 'pavel.krep@gmail.com'
  password_file: 'email_password.txt'

drift_correction:
  type: 'template_matching' # values: 'template_matching', 'mask'
  min_confidence: 0